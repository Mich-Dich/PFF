#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform global_scene_data {
    mat4 view;
    mat4 proj;
    mat4 viewproj;
    vec4 ambient_color;
    vec4 sunlight_direction; // w for sun power
    vec4 sunlight_color;
} scene_data;

layout(set = 1, binding = 0) uniform writeonly image2D outImage;

layout(push_constant) uniform constants {
    mat4    inverse_view;
    vec4    middle_sky_color;
    vec4    horizon_sky_color;
    vec2    image_size;
    float   sun_distance;
    float   sun_radius;
    float   FOV_y;

    // Cloud parameters
    float   cloud_hight;
    float   time;
    float   cloud_density;
    vec4    cloud_color;
    vec2    cloud_speed;
    float   cloud_coverage;
} PushConstants;

// 2D Random
float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

// 2D Noise
float noise(vec2 pos) {
    vec2 i = floor(pos);
    vec2 f = fract(pos);
    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// Fractal Brownian Motion
float fbm(vec2 pos, int octaves, float persistence) {
    float total = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float maxValue = 0.0;
    for(int i = 0; i < octaves; ++i) {
        total += noise(pos * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }
    return total / maxValue;
}

// Shared variables
shared vec2 shared_sun_uv;
shared bool shared_sun_visible;
shared float shared_sun_radius;

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = ivec2(PushConstants.image_size);
    if (texelCoord.x >= size.x || texelCoord.y >= size.y)
        return;

    // First thread computes sun position
    if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
        vec3 sun_dir = normalize(scene_data.sunlight_direction.xyz);
        vec3 center = sun_dir * PushConstants.sun_distance;
        vec3 up = abs(dot(sun_dir, vec3(0,1,0))) < 0.99 ? vec3(0,1,0) : vec3(1,0,0);
        vec3 U = normalize(cross(sun_dir, up));
        vec3 R = center + U * PushConstants.sun_radius;

        vec4 clipC = scene_data.viewproj * vec4(center, 1.0);
        vec4 clipR = scene_data.viewproj * vec4(R, 1.0);

        if (clipC.w > 0.0) {
            vec2 ndcC = clipC.xy / clipC.w;
            vec2 ndcR = clipR.xy / clipR.w;
            shared_sun_uv = ndcC * 0.5 + 0.5;
            shared_sun_visible = true;

            float aspect = float(size.y) / float(size.x);
            vec2 d = ndcR - ndcC;
            d.y *= aspect;
            shared_sun_radius = length(d) * 0.5; 
        } else {
            shared_sun_visible = false;
        }
    }

    barrier();

    // Calculate sky color gradient
    vec2 uv = vec2(texelCoord) / vec2(size);
    vec2 ndc = uv * 2.0 - 1.0;
    float aspectRatio = PushConstants.image_size.x / PushConstants.image_size.y;
    float tanHalfFOV = tan(PushConstants.FOV_y * 0.5);
    vec4 viewDir = vec4(ndc.x * aspectRatio * tanHalfFOV, -ndc.y * tanHalfFOV, -1.35, 0.0);
    viewDir = normalize(viewDir);
    vec3 worldDir = normalize((PushConstants.inverse_view * viewDir).xyz);
    float verticalBlend = clamp(worldDir.y, 0.0, 1.0);
    vec4 color = mix(PushConstants.horizon_sky_color, PushConstants.middle_sky_color, verticalBlend);

    // Cloud calculation
    float cloud = 0.0;
    if (verticalBlend > 0.0) {
        vec2 cloudPos = (worldDir.xz / max(worldDir.y, 0.01)) * PushConstants.cloud_hight + PushConstants.cloud_speed * PushConstants.time;
        float noiseVal = fbm(cloudPos, 4, 0.5);
        float horizonFactor = 1.0 - verticalBlend;
        float coverage = mix(PushConstants.cloud_coverage * 0.3, 
                            PushConstants.cloud_coverage, 
                            verticalBlend);
        float density = mix(PushConstants.cloud_density * 2.0, 
                        PushConstants.cloud_density, 
                        verticalBlend);
        cloud = smoothstep(coverage, coverage + density, noiseVal);
        cloud *= pow(horizonFactor, 0.5);
        cloud *= smoothstep(0.0, 0.05, verticalBlend);
        color.rgb = mix(color.rgb, 
                    PushConstants.cloud_color.rgb, 
                    cloud * PushConstants.cloud_color.a);
    }

    // Sun disk calculation
    if (shared_sun_visible) {
        vec2 delta = uv - shared_sun_uv;
        delta.y *= float(size.y) / float(size.x);
        if (length(delta) < shared_sun_radius)
            color = vec4(1.0);
    }

    imageStore(outImage, texelCoord, color);
}